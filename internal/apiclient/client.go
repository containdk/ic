// Package apiclient provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.2 DO NOT EDIT.
package apiclient

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"gopkg.in/yaml.v3"

	"github.com/oapi-codegen/runtime"
)

// Cluster Cluster represents a secure cloud stack Kubernetes cluster
type Cluster struct {
	// Context Context is defining the JSON-LD context for dereferencing the data as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Context *map[string]interface{} `json:"@context,omitempty"`

	// Id ID is identifying the node with an IRI as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Id *string `json:"@id,omitempty"`

	// Included Included will container linked resources included here for convenience
	Included *[]map[string]interface{} `json:"@included,omitempty"`

	// Type Type is optional explicit definition of the type of node as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Type *string `json:"@type,omitempty"`

	// Capacity Capacity is the capacity per node type, i.e., control-plane and worker nodes
	Capacity      *map[string]Capacity `json:"capacity,omitempty"`
	ClientVersion *Version             `json:"clientVersion,omitempty"`

	// ClusterType ClusterType specifies the type of cluster sharing
	ClusterType *ClusterType `json:"clusterType,omitempty"`

	// Components Components is a reference to the collection of components detected to be running in the cluster
	Components *string `json:"components,omitempty"`

	// Created Created indicates the time the cluster was created
	Created *time.Time `json:"created,omitempty"`

	// Description Description is the humanreadable cluster description of the cluster
	Description *string `json:"description,omitempty"`

	// DocsSpace DocsSpace is where to find Docs Pages and Device Monitoring
	DocsSpace *string `json:"docsSpace,omitempty"`

	// EnvironmentName EnvironmentName specifies the name of the environment to which the cluster is associated - this is generic determined by the cluster provider and tenants but suggested to be, e.g., "production"
	EnvironmentName *string `json:"environmentName,omitempty"`

	// Fqdn FQDN is deprecated, was a string identifying the cluster with a DNS valid string often also registered in DNS - this will not be provided going forward please use the NRN
	Fqdn *string `json:"fqdn,omitempty"`

	// Images Images is a reference to the collection of images discovered from the cluster
	Images *string `json:"images,omitempty"`

	// InfrastructureProvider InfrastructureProvider indicates the provider of the underlying infrastructure, e.g., azure, aws, netic etc. it may not be possible to determine the infrastructure provider
	InfrastructureProvider *string `json:"infrastructureProvider,omitempty"`

	// JiraProject JiraProject is to help identify where related issues should be created
	JiraProject *string `json:"jiraProject,omitempty"`

	// KubernetesProvider KubernetesProvider indicates the Kubernetes distribution, e.g., rke2, aks, eks, kubeadm, etc.
	KubernetesProvider *string  `json:"kubernetesProvider,omitempty"`
	KubernetesVersion  *Version `json:"kubernetesVersion,omitempty"`

	// Name Name uniquely identifying the cluster within the provider of the cluster
	Name *string `json:"name,omitempty"`

	// Namespaces Namespaces is a reference to the collection of namespace for the cluster
	Namespaces *string `json:"namespaces,omitempty"`

	// Nrn NRN is the Netic Resource Name uniquely identifying the cluster among all other Netic resource names
	Nrn *string `json:"nrn,omitempty"`

	// Partition Partition specifies the partition in which the cluster is running
	Partition *string `json:"partition,omitempty"`

	// Pods Pods is a reference to the collection of pods for the cluster
	Pods *string `json:"pods,omitempty"`

	// Provider Provider identification of cluster provider, i.e., the organizational unit responsible for providing the cluster to the tenants
	Provider *string `json:"provider,omitempty"`

	// Region Region specifies the region in which the cluster is running
	Region *string `json:"region,omitempty"`

	// ResilienceZone ResilienceZone identified the resilienze to which the cluster is associated
	ResilienceZone *string `json:"resilienceZone,omitempty"`

	// Subscription Subscription is the Netic subscription identifier used for accounting - this will only be included when the client is authorized for this information
	Subscription *string `json:"subscription,omitempty"`

	// Timestamp Timestamp indicating the most recent change in cluster data - if the cluster has never sent any data this wont be present
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Vulnerabilities Vulnerabilities is a reference to the collection of vulnerabilities detected from the cluster
	Vulnerabilities *string `json:"vulnerabilities,omitempty"`

	// Workloads Workloads is a reference to the collection of workloads for the cluster
	Workloads *string `json:"workloads,omitempty"`
}

// ClusterType ClusterType specifies the type of cluster sharing
type ClusterType = string

// Clusters Clusters represents a collection of clusters
type Clusters struct {
	// Context Context is defining the JSON-LD context for dereferencing the data as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Context *map[string]interface{} `json:"@context,omitempty"`

	// Id ID is identifying the node with an IRI as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Id *string `json:"@id,omitempty"`

	// Included Included will container linked resources included here for convenience
	Included *[]map[string]interface{} `json:"@included,omitempty"`

	// Type Type is optional explicit definition of the type of node as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Type *string `json:"@type,omitempty"`

	// Clusters Clusters is the identification of the clusters in the collection
	Clusters *[]string `json:"clusters,omitempty"`

	// Count Count is the number of clusters in the collection
	Count *int32 `json:"count,omitempty"`

	// Pagination Pagination contains data on other collection data
	Pagination *Pagination `json:"pagination,omitempty"`

	// Total TotalCount is the total number of clusters
	Total *int32 `json:"total,omitempty"`
}

// Component Component represents a secure cloud stack Kubernetes component
type Component struct {
	// Context Context is defining the JSON-LD context for dereferencing the data as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Context *map[string]interface{} `json:"@context,omitempty"`

	// Id ID is identifying the node with an IRI as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Id *string `json:"@id,omitempty"`

	// Included Included will container linked resources included here for convenience
	Included *[]map[string]interface{} `json:"@included,omitempty"`

	// Type Type is optional explicit definition of the type of node as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Type *string `json:"@type,omitempty"`

	// Clusters Clusters is the clusters that have the components installed
	Clusters *[]ComponentCluster `json:"clusters,omitempty"`

	// ComponentType ComponentType is the type of the component
	ComponentType *string `json:"component_type,omitempty"`

	// Description Description of the component
	Description *string `json:"description,omitempty"`

	// Name Name of the component
	Name *string `json:"name,omitempty"`

	// Namespace Namespace of the component
	Namespace *string `json:"namespace,omitempty"`

	// ResilienceZones ResilienceZones is the resilience zones the component is part of
	ResilienceZones *[]ComponentResilienceZone `json:"resilience_zones,omitempty"`

	// Source Source is the source of the component
	Source *string `json:"source,omitempty"`
}

// ComponentCluster Cluster models a cluster for inclusion
type ComponentCluster struct {
	// Context Context is defining the JSON-LD context for dereferencing the data as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Context *map[string]interface{} `json:"@context,omitempty"`

	// Id ID is identifying the node with an IRI as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Id *string `json:"@id,omitempty"`

	// Included Included will container linked resources included here for convenience
	Included *[]map[string]interface{} `json:"@included,omitempty"`

	// Type Type is optional explicit definition of the type of node as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Type      *string `json:"@type,omitempty"`
	ClusterId *string `json:"cluster_id,omitempty"`
}

// ComponentResilienceZone ResilienceZone models resilience zone for inclusion
type ComponentResilienceZone struct {
	// Context Context is defining the JSON-LD context for dereferencing the data as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Context *map[string]interface{} `json:"@context,omitempty"`

	// Id ID is identifying the node with an IRI as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Id *string `json:"@id,omitempty"`

	// Included Included will container linked resources included here for convenience
	Included *[]map[string]interface{} `json:"@included,omitempty"`

	// Type Type is optional explicit definition of the type of node as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Type    *string `json:"@type,omitempty"`
	Name    *string `json:"name,omitempty"`
	Version *string `json:"version,omitempty"`
}

// Components Components represents a collection of components
type Components struct {
	// Context Context is defining the JSON-LD context for dereferencing the data as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Context *map[string]interface{} `json:"@context,omitempty"`

	// Id ID is identifying the node with an IRI as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Id *string `json:"@id,omitempty"`

	// Included Included will container linked resources included here for convenience
	Included *[]map[string]interface{} `json:"@included,omitempty"`

	// Type Type is optional explicit definition of the type of node as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Type *string `json:"@type,omitempty"`

	// Components Components is the identification of the components in the collection
	Components *[]string `json:"components,omitempty"`

	// Count Count is the number of components in the collection
	Count *int32 `json:"count,omitempty"`

	// Pagination Pagination contains data on other collection data
	Pagination *Pagination `json:"pagination,omitempty"`

	// Total TotalCount is the total number of components
	Total *int32 `json:"total,omitempty"`
}

// CreateCluster CreateCluster represents the information used to create a secure cloud stack Kubernetes cluster
type CreateCluster struct {
	// CustomOperationsURL CustomOperationsURL is the URL for the site that documents the custom operations for the cluster. This must be et if HasCustomOperations is enabled.
	CustomOperationsURL *string `json:"customOperationsURL,omitempty"`

	// Description Description is the humanreadable cluster description of the cluster
	Description *string `json:"description,omitempty"`

	// DocsSpace DocsSpace is where to find Docs Pages and Device Monitoring
	DocsSpace *string `json:"docsSpace,omitempty"`

	// EnvironmentName EnvironmentName specifies the name of the environment to which the cluster is associated - this is generic determined by the cluster provider and tenants but suggested to be, e.g., "production"
	EnvironmentName *string `json:"environmentName,omitempty"`

	// HasApplicationManagement HasApplicationManagement specifies that the service level of the cluster includes Application Management
	HasApplicationManagement *bool `json:"hasApplicationManagement,omitempty"`

	// HasApplicationOperations HasApplicationOperations specifies that the service level of the cluster includes Application Operations. This must be enabled if HasApplicationManagement is enabled.
	HasApplicationOperations *bool `json:"hasApplicationOperations,omitempty"`

	// HasCustomOperations HasCustomOperations specifies that the service level of the cluster includes Custom Operations. This must en enabled if HasTechnicalManagement is disabled.
	HasCustomOperations *bool `json:"hasCustomOperations,omitempty"`

	// HasTechnicalManagement HasTechnicalManagement specifies that the service level of the cluster includes Technical Management. This must be enabled if HasApplicationOperations is enabled.
	HasTechnicalManagement *bool `json:"hasTechnicalManagement,omitempty"`

	// HasTechnicalOperations HasTechnicalOperations specifies that the service level of the cluster includes Technical Operations. This must be enabled if HasTechnicalManagement is enabled.
	HasTechnicalOperations *bool `json:"hasTechnicalOperations,omitempty"`

	// InfrastructureProvider InfrastructureProvider is the name of the entity that provides the infrastructure for the cluster. One of: "netic", "azure", "aws"
	InfrastructureProvider *string `json:"infrastructureProvider,omitempty"`

	// JiraProject JiraProject is to help identify where related issues should be created
	JiraProject *string `json:"jiraProject,omitempty"`

	// Name Name uniquely identifying the cluster within the provider of the cluster
	Name *string `json:"name,omitempty"`

	// Partition Partition is the partition in which the cluster is running. One of: "netic", "azure", "aws"
	Partition *string `json:"partition,omitempty"`

	// Provider Provider identification of cluster provider, i.e., the organizational unit responsible for providing the cluster to the tenants
	Provider *string `json:"provider,omitempty"`

	// Region Region is the region within the partition in which the cluster is running
	Region *string `json:"region,omitempty"`

	// ResilienceZone ResilienceZone is the name of the resilience zone the cluster is running in
	ResilienceZone *string `json:"resilienceZone,omitempty"`

	// SubscriptionID SubscriptionID is the subscription ID associated with the cluster
	SubscriptionID *string `json:"subscriptionID,omitempty"`
}

// GenericResource GenericResource represents a generic resource from the cluster
type GenericResource struct {
	// Context Context is defining the JSON-LD context for dereferencing the data as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Context *map[string]interface{} `json:"@context,omitempty"`

	// Id ID is identifying the node with an IRI as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Id *string `json:"@id,omitempty"`

	// Included Included will container linked resources included here for convenience
	Included *[]map[string]interface{} `json:"@included,omitempty"`

	// Type Type is optional explicit definition of the type of node as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Type *string `json:"@type,omitempty"`

	// Annotations Annotations contains an object with resource annotations
	Annotations *map[string]string `json:"annotations,omitempty"`

	// ApiVersion ApiVersion represents the Kubernetes "apiVersion" (group and version) of the resource
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind Kind represent the Kubernetes "kind" of the resource
	Kind *string `json:"kind,omitempty"`

	// Labels Labels contains an object with resource labels
	Labels *map[string]string `json:"labels,omitempty"`

	// Name Name is the name of the Pod
	Name *string `json:"name,omitempty"`

	// Namespace Namespace is the Kubernetes namespace the pod is running inside of
	Namespace *string `json:"namespace,omitempty"`

	// Owner Owner represents the ultimate owner of the resource. That is the owner reference chain is traversed.
	Owner *string `json:"owner,omitempty"`
}

// KubeConfig KubeConfig represents a kubeconfig yaml/json document for a cluster
type KubeConfig struct {
	// ApiVersion Legacy field from pkg/api/types.go TypeMeta.
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Clusters Clusters is a map of referencable names to cluster configs
	Clusters *[]KubeConfigNamedCluster `json:"clusters,omitempty"`

	// Contexts Contexts is a map of referencable names to context configs
	Contexts *[]KubeConfigNamedContext `json:"contexts,omitempty"`

	// CurrentContext CurrentContext is the name of the context that you would like to use by
	// default
	CurrentContext *string `json:"current-context,omitempty"`

	// Extensions Extensions holds additional information. This is useful for extenders so
	// that reads and writes don't clobber unknown fields
	Extensions *[]KubeConfigNamedExtension `json:"extensions,omitempty"`

	// Kind Legacy field from pkg/api/types.go TypeMeta.
	Kind *string `json:"kind,omitempty"`

	// Preferences Preferences holds general information to be use for cli interactions
	Preferences *KubeConfigPreferences `json:"preferences,omitempty"`

	// Users AuthInfos is a map of referencable names to user configs
	Users *[]KubeConfigNamedAuthInfo `json:"users,omitempty"`
}

// KubeConfigAuthInfo AuthInfo holds the auth information
type KubeConfigAuthInfo struct {
	// As Impersonate is the username to impersonate.  The name matches the flag.
	As *string `json:"as,omitempty"`

	// AsGroups ImpersonateGroups is the groups to impersonate.
	AsGroups *[]string `json:"as-groups,omitempty"`

	// AsUid ImpersonateUID is the uid to impersonate.
	AsUid *string `json:"as-uid,omitempty"`

	// AsUserExtra ImpersonateUserExtra contains additional information for impersonated user.
	AsUserExtra *map[string][]string `json:"as-user-extra,omitempty"`

	// AuthProvider AuthProvider specifies a custom authentication plugin for the kubernetes cluster.
	AuthProvider *KubeConfigAuthProviderConfig `json:"auth-provider,omitempty"`

	// ClientCertificate ClientCertificate is the path to a client cert file for TLS.
	ClientCertificate *string `json:"client-certificate,omitempty"`

	// ClientCertificateData ClientCertificateData contains PEM-encoded data from a client cert file for TLS. Overrides ClientCertificate
	ClientCertificateData *[]int8 `json:"client-certificate-data,omitempty"`

	// ClientKey ClientKey is the path to a client key file for TLS.
	ClientKey *string `json:"client-key,omitempty"`

	// ClientKeyData ClientKeyData contains PEM-encoded data from a client key file for TLS. Overrides ClientKey
	ClientKeyData *[]int8 `json:"client-key-data,omitempty"`

	// Exec Exec specifies a custom exec-based authentication plugin for the kubernetes cluster.
	Exec *KubeConfigExecConfig `json:"exec,omitempty"`

	// Extensions Extensions holds additional information. This is useful for extenders so
	// that reads and writes don't clobber unknown fields
	Extensions *[]KubeConfigNamedExtension `json:"extensions,omitempty"`

	// Password Password is the password for basic authentication to the kubernetes cluster.
	Password *string `json:"password,omitempty"`

	// Token Token is the bearer token for authentication to the kubernetes cluster.
	Token *string `json:"token,omitempty"`

	// TokenFile TokenFile is a pointer to a file that contains a bearer token (as described above).  If both Token and TokenFile are present, Token takes precedence.
	TokenFile *string `json:"tokenFile,omitempty"`

	// Username Username is the username for basic authentication to the kubernetes cluster.
	Username *string `json:"username,omitempty"`
}

// KubeConfigAuthProviderConfig AuthProvider specifies a custom authentication plugin for the kubernetes cluster.
type KubeConfigAuthProviderConfig struct {
	Config *map[string]string `json:"config,omitempty"`
	Name   *string            `json:"name,omitempty"`
}

// KubeConfigCluster Cluster holds the cluster information
type KubeConfigCluster struct {
	// CertificateAuthority CertificateAuthority is the path to a cert file for the certificate authority.
	CertificateAuthority *string `json:"certificate-authority,omitempty"`

	// CertificateAuthorityData CertificateAuthorityData contains PEM-encoded certificate authority certificates. Overrides CertificateAuthority
	CertificateAuthorityData *[]int8 `json:"certificate-authority-data,omitempty"`

	// DisableCompression DisableCompression allows client to opt-out of response compression for all requests to the server. This is useful
	// to speed up requests (specifically lists) when client-server network bandwidth is ample, by saving time on
	// compression (server-side) and decompression (client-side): https://github.com/kubernetes/kubernetes/issues/112296.
	DisableCompression *bool `json:"disable-compression,omitempty"`

	// Extensions Extensions holds additional information. This is useful for extenders so that reads and writes don't clobber unknown fields
	Extensions *[]KubeConfigNamedExtension `json:"extensions,omitempty"`

	// InsecureSkipTlsVerify InsecureSkipTLSVerify skips the validity check for the server's certificate. This will make your HTTPS connections insecure.
	InsecureSkipTlsVerify *bool `json:"insecure-skip-tls-verify,omitempty"`

	// ProxyUrl ProxyURL is the URL to the proxy to be used for all requests made by this
	// client. URLs with "http", "https", and "socks5" schemes are supported.  If
	// this configuration is not provided or the empty string, the client
	// attempts to construct a proxy configuration from http_proxy and
	// https_proxy environment variables. If these environment variables are not
	// set, the client does not attempt to proxy requests.
	//
	// socks5 proxying does not currently support spdy streaming endpoints (exec,
	// attach, port forward).
	ProxyUrl *string `json:"proxy-url,omitempty"`

	// Server Server is the address of the kubernetes cluster (https://hostname:port).
	Server *string `json:"server,omitempty"`

	// TlsServerName TLSServerName is used to check server certificate. If TLSServerName is empty, the hostname used to contact the server is used.
	TlsServerName *string `json:"tls-server-name,omitempty"`
}

// KubeConfigContext Context holds the context information
type KubeConfigContext struct {
	// Cluster Cluster is the name of the cluster for this context
	Cluster *string `json:"cluster,omitempty"`

	// Extensions Extensions holds additional information. This is useful for extenders so that reads and writes don't clobber unknown fields
	Extensions *[]KubeConfigNamedExtension `json:"extensions,omitempty"`

	// Namespace Namespace is the default namespace to use on unspecified requests
	Namespace *string `json:"namespace,omitempty"`

	// User AuthInfo is the name of the authInfo for this context
	User *string `json:"user,omitempty"`
}

// KubeConfigExecConfig Exec specifies a custom exec-based authentication plugin for the kubernetes cluster.
type KubeConfigExecConfig struct {
	// ApiVersion Preferred input version of the ExecInfo. The returned ExecCredentials MUST use
	// the same encoding version as the input.
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Args Arguments to pass to the command when executing it.
	Args *[]string `json:"args,omitempty"`

	// Command Command to execute.
	Command *string `json:"command,omitempty"`

	// Env Env defines additional environment variables to expose to the process. These
	// are unioned with the host's environment, as well as variables client-go uses
	// to pass argument to the plugin.
	Env *[]KubeConfigExecEnvVar `json:"env,omitempty"`

	// InstallHint This text is shown to the user when the executable doesn't seem to be
	// present. For example, `brew install foo-cli` might be a good InstallHint for
	// foo-cli on Mac OS systems.
	InstallHint *string `json:"installHint,omitempty"`

	// InteractiveMode InteractiveMode determines this plugin's relationship with standard input. Valid
	// values are "Never" (this exec plugin never uses standard input), "IfAvailable" (this
	// exec plugin wants to use standard input if it is available), or "Always" (this exec
	// plugin requires standard input to function). See ExecInteractiveMode values for more
	// details.
	//
	// If APIVersion is client.authentication.k8s.io/v1alpha1 or
	// client.authentication.k8s.io/v1beta1, then this field is optional and defaults
	// to "IfAvailable" when unset. Otherwise, this field is required.
	InteractiveMode *KubeConfigExecInteractiveMode `json:"interactiveMode,omitempty"`

	// ProvideClusterInfo ProvideClusterInfo determines whether or not to provide cluster information,
	// which could potentially contain very large CA data, to this exec plugin as a
	// part of the KUBERNETES_EXEC_INFO environment variable. By default, it is set
	// to false. Package k8s.io/client-go/tools/auth/exec provides helper methods for
	// reading this environment variable.
	ProvideClusterInfo *bool `json:"provideClusterInfo,omitempty"`
}

// KubeConfigExecEnvVar defines model for KubeConfigExecEnvVar.
type KubeConfigExecEnvVar struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// KubeConfigExecInteractiveMode InteractiveMode determines this plugin's relationship with standard input. Valid
// values are "Never" (this exec plugin never uses standard input), "IfAvailable" (this
// exec plugin wants to use standard input if it is available), or "Always" (this exec
// plugin requires standard input to function). See ExecInteractiveMode values for more
// details.
//
// If APIVersion is client.authentication.k8s.io/v1alpha1 or
// client.authentication.k8s.io/v1beta1, then this field is optional and defaults
// to "IfAvailable" when unset. Otherwise, this field is required.
type KubeConfigExecInteractiveMode = string

// KubeConfigNamedAuthInfo defines model for KubeConfigNamedAuthInfo.
type KubeConfigNamedAuthInfo struct {
	// Name Name is the nickname for this AuthInfo
	Name *string `json:"name,omitempty"`

	// User AuthInfo holds the auth information
	User *KubeConfigAuthInfo `json:"user,omitempty"`
}

// KubeConfigNamedCluster defines model for KubeConfigNamedCluster.
type KubeConfigNamedCluster struct {
	// Cluster Cluster holds the cluster information
	Cluster *KubeConfigCluster `json:"cluster,omitempty"`

	// Name Name is the nickname for this Cluster
	Name *string `json:"name,omitempty"`
}

// KubeConfigNamedContext defines model for KubeConfigNamedContext.
type KubeConfigNamedContext struct {
	// Context Context holds the context information
	Context *KubeConfigContext `json:"context,omitempty"`

	// Name Name is the nickname for this Context
	Name *string `json:"name,omitempty"`
}

// KubeConfigNamedExtension defines model for KubeConfigNamedExtension.
type KubeConfigNamedExtension struct {
	// Extension Extension holds the extension information
	Extension *RawExtension `json:"extension,omitempty"`

	// Name Name is the nickname for this Extension
	Name *string `json:"name,omitempty"`
}

// KubeConfigPreferences Preferences holds general information to be use for cli interactions
type KubeConfigPreferences struct {
	Colors *bool `json:"colors,omitempty"`

	// Extensions Extensions holds additional information. This is useful for extenders so
	// that reads and writes don't clobber unknown fields
	Extensions *[]KubeConfigNamedExtension `json:"extensions,omitempty"`
}

// Node Node represents properties of a node running in a cluster
type Node struct {
	// Context Context is defining the JSON-LD context for dereferencing the data as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Context *map[string]interface{} `json:"@context,omitempty"`

	// Id ID is identifying the node with an IRI as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Id *string `json:"@id,omitempty"`

	// Included Included will container linked resources included here for convenience
	Included *[]map[string]interface{} `json:"@included,omitempty"`

	// Type Type is optional explicit definition of the type of node as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Type *string `json:"@type,omitempty"`

	// AllocatableCoresMillis AllocatableCPUMillis is the total amount of allocatable millicores
	AllocatableCoresMillis *int64 `json:"allocatableCoresMillis,omitempty"`

	// AllocatableMemoryBytes AllocatableMemoryBytes is the total amount of allocatable bytes of memory
	AllocatableMemoryBytes *int64 `json:"allocatableMemoryBytes,omitempty"`

	// CapacityCoresMillis CapacityCPUMillis is the total amount of millicores
	CapacityCoresMillis *int64 `json:"capacityCoresMillis,omitempty"`

	// CapacityMemoryBytes CapacityMemoryBytes is the total amount of bytes of memory
	CapacityMemoryBytes *int64 `json:"capacityMemoryBytes,omitempty"`

	// ContainerRuntimeVersion ContainerRuntimeVersion is the version of the container runtime running on the node
	ContainerRuntimeVersion *string `json:"containerRuntimeVersion,omitempty"`

	// CriName CRI is the name of the CRI
	CriName *string `json:"criName,omitempty"`

	// CriVersion CRIVersion is the version of the CRI
	CriVersion *string `json:"criVersion,omitempty"`

	// IsControlPlane IsControlPlane is true if the node is a control plane node
	IsControlPlane *bool `json:"isControlPlane,omitempty"`

	// KernelVersion KernelVersion is the version of the linux kernel running on the node
	KernelVersion *string `json:"kernelVersion,omitempty"`

	// KubeProxyVersion KubeProxyVersion is the version of kubeproxy running on the node
	KubeProxyVersion *string `json:"kubeProxyVersion,omitempty"`

	// KubeletVersion KubeletVersion is the version of kubelet running on the node
	KubeletVersion *string `json:"kubeletVersion,omitempty"`

	// Name Name is the name of the Node
	Name *string `json:"name,omitempty"`

	// Provider Provider is the name of the provider that created the cluster node
	Provider *string `json:"provider,omitempty"`

	// Role Role is the role of the Node
	Role *string `json:"role,omitempty"`

	// TopologyRegion TopologyRegion is the region in which the node exists
	TopologyRegion *string `json:"topologyRegion,omitempty"`

	// TopologyZone TopologyZone is the zone in which the node exists
	TopologyZone *string `json:"topologyZone,omitempty"`
}

// Nodes Nodes represents a partial collection of nodes
type Nodes struct {
	// Context Context is defining the JSON-LD context for dereferencing the data as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Context *map[string]interface{} `json:"@context,omitempty"`

	// Id ID is identifying the node with an IRI as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Id *string `json:"@id,omitempty"`

	// Included Included will container linked resources included here for convenience
	Included *[]map[string]interface{} `json:"@included,omitempty"`

	// Type Type is optional explicit definition of the type of node as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Type *string `json:"@type,omitempty"`

	// Count Count is the number of nodes in the returned collection
	Count *int32 `json:"count,omitempty"`

	// Nodes Nodes is the identification of the nodes in the collection
	Nodes *[]string `json:"nodes,omitempty"`

	// Pagination Pagination contains data on other collection data
	Pagination *Pagination `json:"pagination,omitempty"`

	// Total TotalCount is the total number of nodes
	Total *int32 `json:"total,omitempty"`
}

// Pagination Pagination contains data on other collection data
type Pagination struct {
	// First First is link to the first page in the collection
	First *string `json:"first,omitempty"`

	// Last Last is link to the last page in the collection
	Last *string `json:"last,omitempty"`

	// Next Next is link to the next page, if any
	Next *string `json:"next,omitempty"`

	// Prev Prev is link to the previous page, if any
	Prev *string `json:"prev,omitempty"`
}

// Pods Pods represents a partial collection of pods
type Pods struct {
	// Context Context is defining the JSON-LD context for dereferencing the data as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Context *map[string]interface{} `json:"@context,omitempty"`

	// Id ID is identifying the node with an IRI as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Id *string `json:"@id,omitempty"`

	// Included Included will container linked resources included here for convenience
	Included *[]map[string]interface{} `json:"@included,omitempty"`

	// Type Type is optional explicit definition of the type of node as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Type *string `json:"@type,omitempty"`

	// Count Count is the number of pods in the returned collection
	Count *int32 `json:"count,omitempty"`

	// Pagination Pagination contains data on other collection data
	Pagination *Pagination `json:"pagination,omitempty"`

	// Pods Pods is the identification of the pods in the collection
	Pods *[]string `json:"pods,omitempty"`

	// Total TotalCount is the total number of pods
	Total *int32 `json:"total,omitempty"`
}

// Problem Problem is simple implementation of (RFC9457)[https://datatracker.ietf.org/doc/html/rfc9457]
type Problem struct {
	// Detail Detail is humanreadable explanation of the specific occurence of the problem RFC-9457#3.1.4
	Detail *string `json:"detail,omitempty"`

	// Instance Instance identifies the specific instance of the problem RFC-9457#3.1.5
	Instance *string `json:"instance,omitempty"`

	// Status Status is the http status code and must be consistent with the server status code RFC-9457#3.1.2
	Status *int32 `json:"status,omitempty"`

	// Title Title is short humanreadable summary RFC-9457#3.1.3
	Title *string `json:"title,omitempty"`

	// Type Type identify problem type RFC-9457#3.1.1
	Type *string `json:"type,omitempty"`
}

// RawExtension Extension holds the extension information
type RawExtension = map[string]interface{}

// Resources Resources represents a partial collection of resources which may be of different type
type Resources struct {
	// Context Context is defining the JSON-LD context for dereferencing the data as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Context *map[string]interface{} `json:"@context,omitempty"`

	// Id ID is identifying the node with an IRI as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Id *string `json:"@id,omitempty"`

	// Included Included will container linked resources included here for convenience
	Included *[]map[string]interface{} `json:"@included,omitempty"`

	// Type Type is optional explicit definition of the type of node as stated in the JSON-LD specification https://www.w3.org/TR/json-ld/#keywords
	Type *string `json:"@type,omitempty"`

	// Count Count is the number of pods in the returned collection
	Count *int32 `json:"count,omitempty"`

	// Pagination Pagination contains data on other collection data
	Pagination *Pagination `json:"pagination,omitempty"`

	// Resource Resources is the identifiers for the resources in the collection
	Resource *[]string `json:"resource,omitempty"`

	// Total TotalCount is the total number of pods
	Total *int32 `json:"total,omitempty"`
}

// UpdateCluster UpdateCluster represents the information used to update a secure cloud stack Kubernetes cluster's metadata
type UpdateCluster struct {
	// CustomOperationsURL CustomOperationsURL is the URL for the site that documents the custom operations for the cluster. This must be et if HasCustomOperations is enabled.
	CustomOperationsURL *string `json:"customOperationsURL,omitempty"`

	// Description Description is the humanreadable cluster description of the cluster
	Description *string `json:"description,omitempty"`

	// DocsSpace DocsSpace is where to find Docs Pages and Device Monitoring
	DocsSpace *string `json:"docsSpace,omitempty"`

	// EnvironmentName EnvironmentName specifies the name of the environment to which the cluster is associated - this is generic determined by the cluster provider and tenants but suggested to be, e.g., "production"
	EnvironmentName *string `json:"environmentName,omitempty"`

	// HasApplicationManagement HasApplicationManagement specifies that the service level of the cluster includes Application Management
	HasApplicationManagement *bool `json:"hasApplicationManagement,omitempty"`

	// HasApplicationOperations HasApplicationOperations specifies that the service level of the cluster includes Application Operations. This must be enabled if HasApplicationManagement is enabled.
	HasApplicationOperations *bool `json:"hasApplicationOperations,omitempty"`

	// HasCustomOperations HasCustomOperations specifies that the service level of the cluster includes Custom Operations. This must en enabled if HasTechnicalManagement is disabled.
	HasCustomOperations *bool `json:"hasCustomOperations,omitempty"`

	// HasTechnicalManagement HasTechnicalManagement specifies that the service level of the cluster includes Technical Management. This must be enabled if HasApplicationOperations is enabled.
	HasTechnicalManagement *bool `json:"hasTechnicalManagement,omitempty"`

	// HasTechnicalOperations HasTechnicalOperations specifies that the service level of the cluster includes Technical Operations. This must be enabled if HasTechnicalManagement is enabled.
	HasTechnicalOperations *bool `json:"hasTechnicalOperations,omitempty"`

	// InfrastructureProvider InfrastructureProvider is the name of the entity that provides the infrastructure for the cluster. One of: "netic", "azure", "aws"
	InfrastructureProvider *string `json:"infrastructureProvider,omitempty"`

	// JiraProject JiraProject is to help identify where related issues should be created
	JiraProject *string `json:"jiraProject,omitempty"`

	// ResilienceZone ResilienceZone is the name of the resilience zone the cluster is running in
	ResilienceZone *string `json:"resilienceZone,omitempty"`

	// SubscriptionID SubscriptionID is the subscription ID associated with the cluster
	SubscriptionID *string `json:"subscriptionID,omitempty"`
}

// Capacity defines model for capacity.
type Capacity struct {
	// CoresMillis CPU is the total amount of allocatable millicores
	CoresMillis *int64 `json:"coresMillis,omitempty"`

	// MemoryBytes Memory is the total amount of allocatable bytes of memory
	MemoryBytes *int64 `json:"memoryBytes,omitempty"`

	// Nodes Nodes is the total number of nodes
	Nodes *int64 `json:"nodes,omitempty"`
}

// Version defines model for version.
type Version struct {
	// Commit Commit is the commit sha of the source code for the binary
	Commit *string `json:"commit,omitempty"`

	// Date Date is the date the binary was build
	Date *string `json:"date,omitempty"`

	// Version Version is the semver version
	Version *string `json:"version,omitempty"`
}

// CreateClusterJSONRequestBody defines body for CreateCluster for application/json ContentType.
type CreateClusterJSONRequestBody = CreateCluster

// UpdateClusterJSONRequestBody defines body for UpdateCluster for application/json ContentType.
type UpdateClusterJSONRequestBody = UpdateCluster

// UpdateClusterKubeConfigJSONRequestBody defines body for UpdateClusterKubeConfig for application/json ContentType.
type UpdateClusterKubeConfigJSONRequestBody = KubeConfig

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListClusters request
	ListClusters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClusterWithBody request with any body
	CreateClusterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCluster(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCluster request
	DeleteCluster(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCluster request
	GetCluster(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClusterWithBody request with any body
	UpdateClusterWithBody(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCluster(ctx context.Context, clusterId string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterKubeConfig request
	GetClusterKubeConfig(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClusterKubeConfigWithBody request with any body
	UpdateClusterKubeConfigWithBody(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateClusterKubeConfig(ctx context.Context, clusterId string, body UpdateClusterKubeConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNodes request
	ListNodes(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNode request
	GetNode(ctx context.Context, clusterId string, nodeName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPods request
	ListPods(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResource request
	GetResource(ctx context.Context, clusterId string, group string, version string, namespace string, resource string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListResourcesByType request
	ListResourcesByType(ctx context.Context, clusterId string, group string, version string, resourceType string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListComponents request
	ListComponents(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComponent request
	GetComponent(ctx context.Context, namespace string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListClusters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClustersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCluster(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCluster(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterRequest(c.Server, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCluster(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterRequest(c.Server, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterWithBody(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequestWithBody(c.Server, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCluster(ctx context.Context, clusterId string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequest(c.Server, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterKubeConfig(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterKubeConfigRequest(c.Server, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterKubeConfigWithBody(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterKubeConfigRequestWithBody(c.Server, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterKubeConfig(ctx context.Context, clusterId string, body UpdateClusterKubeConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterKubeConfigRequest(c.Server, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNodes(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNodesRequest(c.Server, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNode(ctx context.Context, clusterId string, nodeName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNodeRequest(c.Server, clusterId, nodeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPods(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPodsRequest(c.Server, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResource(ctx context.Context, clusterId string, group string, version string, namespace string, resource string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceRequest(c.Server, clusterId, group, version, namespace, resource, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListResourcesByType(ctx context.Context, clusterId string, group string, version string, resourceType string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListResourcesByTypeRequest(c.Server, clusterId, group, version, resourceType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListComponents(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListComponentsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComponent(ctx context.Context, namespace string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComponentRequest(c.Server, namespace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListClustersRequest generates requests for ListClusters
func NewListClustersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClusterRequest calls the generic CreateCluster builder with application/json body
func NewCreateClusterRequest(server string, body CreateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClusterRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateClusterRequestWithBody generates requests for CreateCluster with any type of body
func NewCreateClusterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClusterRequest generates requests for DeleteCluster
func NewDeleteClusterRequest(server string, clusterId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterRequest generates requests for GetCluster
func NewGetClusterRequest(server string, clusterId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateClusterRequest calls the generic UpdateCluster builder with application/json body
func NewUpdateClusterRequest(server string, clusterId string, body UpdateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClusterRequestWithBody(server, clusterId, "application/json", bodyReader)
}

// NewUpdateClusterRequestWithBody generates requests for UpdateCluster with any type of body
func NewUpdateClusterRequestWithBody(server string, clusterId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClusterKubeConfigRequest generates requests for GetClusterKubeConfig
func NewGetClusterKubeConfigRequest(server string, clusterId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/kubeconfig", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateClusterKubeConfigRequest calls the generic UpdateClusterKubeConfig builder with application/json body
func NewUpdateClusterKubeConfigRequest(server string, clusterId string, body UpdateClusterKubeConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClusterKubeConfigRequestWithBody(server, clusterId, "application/json", bodyReader)
}

// NewUpdateClusterKubeConfigRequestWithBody generates requests for UpdateClusterKubeConfig with any type of body
func NewUpdateClusterKubeConfigRequestWithBody(server string, clusterId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/kubeconfig", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListNodesRequest generates requests for ListNodes
func NewListNodesRequest(server string, clusterId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/nodes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNodeRequest generates requests for GetNode
func NewGetNodeRequest(server string, clusterId string, nodeName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "nodeName", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/nodes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPodsRequest generates requests for ListPods
func NewListPodsRequest(server string, clusterId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/pods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceRequest generates requests for GetResource
func NewGetResourceRequest(server string, clusterId string, group string, version string, namespace string, resource string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "group", runtime.ParamLocationPath, group)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "resource", runtime.ParamLocationPath, resource)
	if err != nil {
		return nil, err
	}

	var pathParam5 string

	pathParam5, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/resources/%s/%s/namespaces/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4, pathParam5)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListResourcesByTypeRequest generates requests for ListResourcesByType
func NewListResourcesByTypeRequest(server string, clusterId string, group string, version string, resourceType string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "group", runtime.ParamLocationPath, group)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "resourceType", runtime.ParamLocationPath, resourceType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/resources/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListComponentsRequest generates requests for ListComponents
func NewListComponentsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/components")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetComponentRequest generates requests for GetComponent
func NewGetComponentRequest(server string, namespace string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/components/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListClustersWithResponse request
	ListClustersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListClustersResponse, error)

	// CreateClusterWithBodyWithResponse request with any body
	CreateClusterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	CreateClusterWithResponse(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	// DeleteClusterWithResponse request
	DeleteClusterWithResponse(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error)

	// GetClusterWithResponse request
	GetClusterWithResponse(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*GetClusterResponse, error)

	// UpdateClusterWithBodyWithResponse request with any body
	UpdateClusterWithBodyWithResponse(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	UpdateClusterWithResponse(ctx context.Context, clusterId string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	// GetClusterKubeConfigWithResponse request
	GetClusterKubeConfigWithResponse(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*GetClusterKubeConfigResponse, error)

	// UpdateClusterKubeConfigWithBodyWithResponse request with any body
	UpdateClusterKubeConfigWithBodyWithResponse(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterKubeConfigResponse, error)

	UpdateClusterKubeConfigWithResponse(ctx context.Context, clusterId string, body UpdateClusterKubeConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterKubeConfigResponse, error)

	// ListNodesWithResponse request
	ListNodesWithResponse(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*ListNodesResponse, error)

	// GetNodeWithResponse request
	GetNodeWithResponse(ctx context.Context, clusterId string, nodeName string, reqEditors ...RequestEditorFn) (*GetNodeResponse, error)

	// ListPodsWithResponse request
	ListPodsWithResponse(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*ListPodsResponse, error)

	// GetResourceWithResponse request
	GetResourceWithResponse(ctx context.Context, clusterId string, group string, version string, namespace string, resource string, name string, reqEditors ...RequestEditorFn) (*GetResourceResponse, error)

	// ListResourcesByTypeWithResponse request
	ListResourcesByTypeWithResponse(ctx context.Context, clusterId string, group string, version string, resourceType string, reqEditors ...RequestEditorFn) (*ListResourcesByTypeResponse, error)

	// ListComponentsWithResponse request
	ListComponentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListComponentsResponse, error)

	// GetComponentWithResponse request
	GetComponentWithResponse(ctx context.Context, namespace string, name string, reqEditors ...RequestEditorFn) (*GetComponentResponse, error)
}

type ListClustersResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON400          *Problem
	ApplicationproblemJSON400     *Problem
	ApplicationldJSON401          *Problem
	ApplicationproblemJSON401     *Problem
	ApplicationldJSON500          *Problem
	ApplicationproblemJSON500     *Problem
	ApplicationldJSONDefault      *Clusters
	ApplicationproblemJSONDefault *Clusters
}

// Status returns HTTPResponse.Status
func (r ListClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClusterResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON201          *Cluster
	ApplicationproblemJSON201     *Cluster
	ApplicationldJSON400          *Problem
	ApplicationproblemJSON400     *Problem
	ApplicationldJSON401          *Problem
	ApplicationproblemJSON401     *Problem
	ApplicationldJSON403          *Problem
	ApplicationproblemJSON403     *Problem
	ApplicationldJSON409          *Problem
	ApplicationproblemJSON409     *Problem
	ApplicationldJSON500          *Problem
	ApplicationproblemJSON500     *Problem
	ApplicationldJSONDefault      *Cluster
	ApplicationproblemJSONDefault *Cluster
}

// Status returns HTTPResponse.Status
func (r CreateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON401          *Problem
	ApplicationproblemJSON401     *Problem
	ApplicationldJSON404          *Problem
	ApplicationproblemJSON404     *Problem
	ApplicationldJSON500          *Problem
	ApplicationproblemJSON500     *Problem
	ApplicationldJSONDefault      *Cluster
	ApplicationproblemJSONDefault *Cluster
}

// Status returns HTTPResponse.Status
func (r GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClusterResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON400          *Problem
	ApplicationproblemJSON400     *Problem
	ApplicationldJSON401          *Problem
	ApplicationproblemJSON401     *Problem
	ApplicationldJSON403          *Problem
	ApplicationproblemJSON403     *Problem
	ApplicationldJSON404          *Problem
	ApplicationproblemJSON404     *Problem
	ApplicationldJSON500          *Problem
	ApplicationproblemJSON500     *Problem
	ApplicationldJSONDefault      *Cluster
	ApplicationproblemJSONDefault *Cluster
}

// Status returns HTTPResponse.Status
func (r UpdateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterKubeConfigResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON401     *Problem
	YAML401                       *Problem
	ApplicationproblemJSON404     *Problem
	YAML404                       *Problem
	ApplicationproblemJSON500     *Problem
	YAML500                       *Problem
	ApplicationproblemJSONDefault *KubeConfig
	YAMLDefault                   *KubeConfig
}

// Status returns HTTPResponse.Status
func (r GetClusterKubeConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterKubeConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClusterKubeConfigResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON401 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r UpdateClusterKubeConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClusterKubeConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNodesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON400          *Problem
	ApplicationproblemJSON400     *Problem
	ApplicationldJSON401          *Problem
	ApplicationproblemJSON401     *Problem
	ApplicationldJSON403          *Problem
	ApplicationproblemJSON403     *Problem
	ApplicationldJSON500          *Problem
	ApplicationproblemJSON500     *Problem
	ApplicationldJSONDefault      *Nodes
	ApplicationproblemJSONDefault *Nodes
}

// Status returns HTTPResponse.Status
func (r ListNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNodeResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON401          *Problem
	ApplicationproblemJSON401     *Problem
	ApplicationldJSON404          *Problem
	ApplicationproblemJSON404     *Problem
	ApplicationldJSON500          *Problem
	ApplicationproblemJSON500     *Problem
	ApplicationldJSONDefault      *Node
	ApplicationproblemJSONDefault *Node
}

// Status returns HTTPResponse.Status
func (r GetNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPodsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON400          *Problem
	ApplicationproblemJSON400     *Problem
	ApplicationldJSON401          *Problem
	ApplicationproblemJSON401     *Problem
	ApplicationldJSONDefault      *Pods
	ApplicationproblemJSONDefault *Pods
}

// Status returns HTTPResponse.Status
func (r ListPodsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPodsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON401          *Problem
	ApplicationproblemJSON401     *Problem
	ApplicationldJSON500          *Problem
	ApplicationproblemJSON500     *Problem
	ApplicationldJSONDefault      *GenericResource
	ApplicationproblemJSONDefault *GenericResource
}

// Status returns HTTPResponse.Status
func (r GetResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListResourcesByTypeResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON400          *Problem
	ApplicationproblemJSON400     *Problem
	ApplicationldJSON401          *Problem
	ApplicationproblemJSON401     *Problem
	ApplicationldJSON500          *Problem
	ApplicationproblemJSON500     *Problem
	ApplicationldJSONDefault      *Resources
	ApplicationproblemJSONDefault *Resources
}

// Status returns HTTPResponse.Status
func (r ListResourcesByTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResourcesByTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListComponentsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON400          *Problem
	ApplicationproblemJSON400     *Problem
	ApplicationldJSON401          *Problem
	ApplicationproblemJSON401     *Problem
	ApplicationldJSON500          *Problem
	ApplicationproblemJSON500     *Problem
	ApplicationldJSONDefault      *Components
	ApplicationproblemJSONDefault *Components
}

// Status returns HTTPResponse.Status
func (r ListComponentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListComponentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComponentResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON401          *Problem
	ApplicationproblemJSON401     *Problem
	ApplicationldJSON404          *Problem
	ApplicationproblemJSON404     *Problem
	ApplicationldJSON500          *Problem
	ApplicationproblemJSON500     *Problem
	ApplicationldJSONDefault      *Component
	ApplicationproblemJSONDefault *Component
}

// Status returns HTTPResponse.Status
func (r GetComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListClustersWithResponse request returning *ListClustersResponse
func (c *ClientWithResponses) ListClustersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListClustersResponse, error) {
	rsp, err := c.ListClusters(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClustersResponse(rsp)
}

// CreateClusterWithBodyWithResponse request with arbitrary body returning *CreateClusterResponse
func (c *ClientWithResponses) CreateClusterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateClusterWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

func (c *ClientWithResponses) CreateClusterWithResponse(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateCluster(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

// DeleteClusterWithResponse request returning *DeleteClusterResponse
func (c *ClientWithResponses) DeleteClusterWithResponse(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error) {
	rsp, err := c.DeleteCluster(ctx, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterResponse(rsp)
}

// GetClusterWithResponse request returning *GetClusterResponse
func (c *ClientWithResponses) GetClusterWithResponse(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*GetClusterResponse, error) {
	rsp, err := c.GetCluster(ctx, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterResponse(rsp)
}

// UpdateClusterWithBodyWithResponse request with arbitrary body returning *UpdateClusterResponse
func (c *ClientWithResponses) UpdateClusterWithBodyWithResponse(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateClusterWithBody(ctx, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

func (c *ClientWithResponses) UpdateClusterWithResponse(ctx context.Context, clusterId string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateCluster(ctx, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

// GetClusterKubeConfigWithResponse request returning *GetClusterKubeConfigResponse
func (c *ClientWithResponses) GetClusterKubeConfigWithResponse(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*GetClusterKubeConfigResponse, error) {
	rsp, err := c.GetClusterKubeConfig(ctx, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterKubeConfigResponse(rsp)
}

// UpdateClusterKubeConfigWithBodyWithResponse request with arbitrary body returning *UpdateClusterKubeConfigResponse
func (c *ClientWithResponses) UpdateClusterKubeConfigWithBodyWithResponse(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterKubeConfigResponse, error) {
	rsp, err := c.UpdateClusterKubeConfigWithBody(ctx, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterKubeConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdateClusterKubeConfigWithResponse(ctx context.Context, clusterId string, body UpdateClusterKubeConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterKubeConfigResponse, error) {
	rsp, err := c.UpdateClusterKubeConfig(ctx, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterKubeConfigResponse(rsp)
}

// ListNodesWithResponse request returning *ListNodesResponse
func (c *ClientWithResponses) ListNodesWithResponse(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*ListNodesResponse, error) {
	rsp, err := c.ListNodes(ctx, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNodesResponse(rsp)
}

// GetNodeWithResponse request returning *GetNodeResponse
func (c *ClientWithResponses) GetNodeWithResponse(ctx context.Context, clusterId string, nodeName string, reqEditors ...RequestEditorFn) (*GetNodeResponse, error) {
	rsp, err := c.GetNode(ctx, clusterId, nodeName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNodeResponse(rsp)
}

// ListPodsWithResponse request returning *ListPodsResponse
func (c *ClientWithResponses) ListPodsWithResponse(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*ListPodsResponse, error) {
	rsp, err := c.ListPods(ctx, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPodsResponse(rsp)
}

// GetResourceWithResponse request returning *GetResourceResponse
func (c *ClientWithResponses) GetResourceWithResponse(ctx context.Context, clusterId string, group string, version string, namespace string, resource string, name string, reqEditors ...RequestEditorFn) (*GetResourceResponse, error) {
	rsp, err := c.GetResource(ctx, clusterId, group, version, namespace, resource, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceResponse(rsp)
}

// ListResourcesByTypeWithResponse request returning *ListResourcesByTypeResponse
func (c *ClientWithResponses) ListResourcesByTypeWithResponse(ctx context.Context, clusterId string, group string, version string, resourceType string, reqEditors ...RequestEditorFn) (*ListResourcesByTypeResponse, error) {
	rsp, err := c.ListResourcesByType(ctx, clusterId, group, version, resourceType, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListResourcesByTypeResponse(rsp)
}

// ListComponentsWithResponse request returning *ListComponentsResponse
func (c *ClientWithResponses) ListComponentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListComponentsResponse, error) {
	rsp, err := c.ListComponents(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListComponentsResponse(rsp)
}

// GetComponentWithResponse request returning *GetComponentResponse
func (c *ClientWithResponses) GetComponentWithResponse(ctx context.Context, namespace string, name string, reqEditors ...RequestEditorFn) (*GetComponentResponse, error) {
	rsp, err := c.GetComponent(ctx, namespace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComponentResponse(rsp)
}

// ParseListClustersResponse parses an HTTP response from a ListClustersWithResponse call
func ParseListClustersResponse(rsp *http.Response) (*ListClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && true:
		var dest Clusters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSONDefault = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && true:
		var dest Clusters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateClusterResponse parses an HTTP response from a CreateClusterWithResponse call
func ParseCreateClusterResponse(rsp *http.Response) (*CreateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 201:
		var dest Cluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON201 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON403 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON409 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && true:
		var dest Cluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSONDefault = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 201:
		var dest Cluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON201 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 409:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && true:
		var dest Cluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteClusterResponse parses an HTTP response from a DeleteClusterWithResponse call
func ParseDeleteClusterResponse(rsp *http.Response) (*DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetClusterResponse parses an HTTP response from a GetClusterWithResponse call
func ParseGetClusterResponse(rsp *http.Response) (*GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && true:
		var dest Cluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSONDefault = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && true:
		var dest Cluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateClusterResponse parses an HTTP response from a UpdateClusterWithResponse call
func ParseUpdateClusterResponse(rsp *http.Response) (*UpdateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON403 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && true:
		var dest Cluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSONDefault = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && true:
		var dest Cluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetClusterKubeConfigResponse parses an HTTP response from a GetClusterKubeConfigWithResponse call
func ParseGetClusterKubeConfigResponse(rsp *http.Response) (*GetClusterKubeConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterKubeConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest KubeConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 401:
		var dest Problem
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 404:
		var dest Problem
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 500:
		var dest Problem
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest KubeConfig
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseUpdateClusterKubeConfigResponse parses an HTTP response from a UpdateClusterKubeConfigWithResponse call
func ParseUpdateClusterKubeConfigResponse(rsp *http.Response) (*UpdateClusterKubeConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClusterKubeConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListNodesResponse parses an HTTP response from a ListNodesWithResponse call
func ParseListNodesResponse(rsp *http.Response) (*ListNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON403 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && true:
		var dest Nodes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSONDefault = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && true:
		var dest Nodes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetNodeResponse parses an HTTP response from a GetNodeWithResponse call
func ParseGetNodeResponse(rsp *http.Response) (*GetNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && true:
		var dest Node
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSONDefault = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && true:
		var dest Node
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListPodsResponse parses an HTTP response from a ListPodsWithResponse call
func ParseListPodsResponse(rsp *http.Response) (*ListPodsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPodsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && true:
		var dest Pods
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSONDefault = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && true:
		var dest Pods
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetResourceResponse parses an HTTP response from a GetResourceWithResponse call
func ParseGetResourceResponse(rsp *http.Response) (*GetResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && true:
		var dest GenericResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSONDefault = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && true:
		var dest GenericResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListResourcesByTypeResponse parses an HTTP response from a ListResourcesByTypeWithResponse call
func ParseListResourcesByTypeResponse(rsp *http.Response) (*ListResourcesByTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResourcesByTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && true:
		var dest Resources
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSONDefault = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && true:
		var dest Resources
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListComponentsResponse parses an HTTP response from a ListComponentsWithResponse call
func ParseListComponentsResponse(rsp *http.Response) (*ListComponentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListComponentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && true:
		var dest Components
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSONDefault = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && true:
		var dest Components
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetComponentResponse parses an HTTP response from a GetComponentWithResponse call
func ParseGetComponentResponse(rsp *http.Response) (*GetComponentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && true:
		var dest Component
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSONDefault = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/problem+json" && true:
		var dest Component
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}
